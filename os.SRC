; .\os.SRC generated from: os.c
; COMPILER INVOKED BY:
;        D:\c51\c51v952\C51\BIN\C51.EXE os.c BROWSE DEBUG OBJECTEXTEND TABS(2) SRC(.\os.SRC)

$NOMOD51

NAME	OS

P0	DATA	080H
P1	DATA	090H
P2	DATA	0A0H
P3	DATA	0B0H
T0	BIT	0B0H.4
AC	BIT	0D0H.6
T1	BIT	0B0H.5
T2	BIT	090H.0
EA	BIT	0A8H.7
IE	DATA	0A8H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
ES	BIT	0A8H.4
IP	DATA	0B8H
RI	BIT	098H.0
INT0	BIT	0B0H.2
CY	BIT	0D0H.7
TI	BIT	098H.1
INT1	BIT	0B0H.3
RCAP2H	DATA	0CBH
PS	BIT	0B8H.4
SP	DATA	081H
T2EX	BIT	090H.1
OV	BIT	0D0H.2
RCAP2L	DATA	0CAH
C_T2	BIT	0C8H.1
WR	BIT	0B0H.6
RCLK	BIT	0C8H.5
TCLK	BIT	0C8H.4
SBUF	DATA	099H
PCON	DATA	087H
SCON	DATA	098H
TMOD	DATA	089H
TCON	DATA	088H
IE0	BIT	088H.1
IE1	BIT	088H.3
B	DATA	0F0H
CP_RL2	BIT	0C8H.0
ACC	DATA	0E0H
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RB8	BIT	098H.2
TH0	DATA	08CH
EX0	BIT	0A8H.0
IT0	BIT	088H.0
TH1	DATA	08DH
TB8	BIT	098H.3
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
SM0	BIT	098H.7
TL0	DATA	08AH
SM1	BIT	098H.6
TL1	DATA	08BH
SM2	BIT	098H.5
TL2	DATA	0CCH
PT0	BIT	0B8H.1
PT1	BIT	0B8H.3
RS0	BIT	0D0H.3
PT2	BIT	0B8H.5
TR0	BIT	088H.4
RS1	BIT	0D0H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DPH	DATA	083H
DPL	DATA	082H
EXEN2	BIT	0C8H.3
REN	BIT	098H.4
T2CON	DATA	0C8H
RXD	BIT	0B0H.0
TXD	BIT	0B0H.1
F0	BIT	0D0H.5
PSW	DATA	0D0H
?PR?OS_Main?OS       SEGMENT CODE 
?PR?OS_taskDispatch?OS                   SEGMENT CODE 
?PR?OS_TaskRecover?OS                    SEGMENT CODE 
?PR?_sleep?OS        SEGMENT CODE 
?PR?_addTask?OS      SEGMENT CODE 
	EXTRN	CODE (addTasks)
	EXTRN	CODE (?C?OFFXADD)
	EXTRN	CODE (?C?CSTPTR)
	PUBLIC	RN_TASK_IDX
	PUBLIC	Cache_TaskEnter_L
	PUBLIC	Cache_TaskEnter_H
	PUBLIC	i
	PUBLIC	pTAK_RM_STK
	PUBLIC	p_JCB
	PUBLIC	ITRPT_COUNT
	PUBLIC	Cache_ACC
	PUBLIC	_addTask
	PUBLIC	_sleep
	PUBLIC	OS_TaskRecover
	PUBLIC	OS_taskDispatch
	PUBLIC	OS_Main

	DSEG  AT  040H
      Cache_ACC:   DS   1

	DSEG  AT  031H
    ITRPT_COUNT:   DS   1

	DSEG  AT  034H
          p_JCB:   DS   1

	DSEG  AT  032H
    pTAK_RM_STK:   DS   2

	DSEG  AT  043H
              i:   DS   1

	DSEG  AT  042H
Cache_TaskEnter_H:   DS   1

	DSEG  AT  041H
Cache_TaskEnter_L:   DS   1

	DSEG  AT  030H
    RN_TASK_IDX:   DS   1
; #include "os.h"
; 
; uchar RN_TASK_IDX _at_ 0x30; 		  //当前任务下标
; uchar ITRPT_COUNT _at_ 0x31;			//中断次数
; uchar xdata *pTAK_RM_STK _at_ 0x32;//任务RAM栈指针	
; uchar data *p_JCB _at_ 0x34;		  //JCB地址栈指针
; 
; #define C_MAX_TASK_COUNT 0x04		      //最多任务数
; #define C_JCB_START 0x50		      //JCB起始地址
; #define C_TASKs_RAM_START 0x0000	//任务RAM起始地址	
; #define C_sgTASK_SP_SRART 0x80		//任务栈数据起始地址
; #define C_MAIN_SP_START 0x70			//默认栈数据起始地址
; #define C_JCB_CAPACITY 0x08	      //JCB容量
; #define C_TASKs_RAM_CAPACITY 0x20 //单个任务最大容量
; #define C_sgTASK_SP_CAPACITY 0x20	//单个任务栈最大容量
; 
; #define JCB_DESTORY 0x00
; #define JCB_BLOCK 0x01
; #define JCB_RUN 0x02
; 
; uchar data Cache_ACC _at_ 0x40;        //ACC临时变量
; uchar data Cache_TaskEnter_L _at_ 0x41;//任务人口地址L临时变量
; uchar data Cache_TaskEnter_H _at_ 0x42;//任务人口地址H临时变量
; uchar data i _at_ 0x43;                //临时变量i
; 
; extern void addTasks();
; extern void pushTaskData();
; 
; 
; 
; void OS_Main(){

	RSEG  ?PR?OS_Main?OS
OS_Main:
	USING	0
			; SOURCE LINE # 31
; 	addTasks();
			; SOURCE LINE # 32
	LJMP 	addTasks
; END OF OS_Main

; }
; 
; 
; void OS_taskDispatch(){

	RSEG  ?PR?OS_taskDispatch?OS
OS_taskDispatch:
	USING	0
			; SOURCE LINE # 36
; 
; 	//寄存器入栈保护	
; 	for(i=0x08;i<0x10;i++){		
			; SOURCE LINE # 39
	MOV  	i,#08H
?C0002:
; 		//MOV (C_TASKs_RAM_S + D_RN_TASK_IDX*C_sgTAK_RM_CT) + D_pTAK_RM_STK,A
; 		*((uchar xdata *)(C_TASKs_RAM_START + RN_TASK_IDX*C_TASKs_RAM_CAPACITY + pTAK_RM_STK++)) = *((uchar data*)i);
			; SOURCE LINE # 41
	MOV  	R0,i
	MOV  	A,@R0
	MOV  	R7,A
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R4,pTAK_RM_STK
	JNZ  	?C0035
	INC  	pTAK_RM_STK
?C0035:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R4
	MOV  	B,#020H
	MOV  	A,RN_TASK_IDX
	LCALL	?C?OFFXADD
	MOV  	A,R7
	MOVX 	@DPTR,A
; 		
; 	}
			; SOURCE LINE # 43
	INC  	i
	MOV  	A,i
	CJNE 	A,#010H,?C0002
?C0003:
; 	
; 	//寻找下一个任务的下标
; 	i = 0;
			; SOURCE LINE # 46
	CLR  	A
	MOV  	i,A
; 	for(p_JCB = C_JCB_START; p_JCB < C_JCB_START + C_MAX_TASK_COUNT * C_JCB_CAPACITY; p_JCB += C_JCB_CAPACITY){		
			; SOURCE LINE # 47
	MOV  	p_JCB,#050H
?C0005:
	MOV  	A,p_JCB
	CLR  	C
	SUBB 	A,#070H
	JNC  	?C0006
; 		if(*p_JCB  == JCB_BLOCK && i != RN_TASK_IDX){
			; SOURCE LINE # 48
	MOV  	R0,p_JCB
	MOV  	A,@R0
	CJNE 	A,#01H,?C0008
	MOV  	A,i
	XRL  	A,RN_TASK_IDX
	JZ   	?C0008
; 			//上一个任务变为阻塞状态
; 			*((uchar data*)(C_JCB_START + RN_TASK_IDX * C_JCB_CAPACITY)) = JCB_BLOCK;
			; SOURCE LINE # 50
	MOV  	A,RN_TASK_IDX
	MOV  	B,#08H
	MUL  	AB
	ADD  	A,#050H
	MOV  	R0,A
	MOV  	@R0,#01H
; 			//下一任务变成运行态
; 			RN_TASK_IDX = i;
			; SOURCE LINE # 52
	MOV  	RN_TASK_IDX,i
; 			*(p_JCB++) = JCB_RUN;			
			; SOURCE LINE # 53
	MOV  	R7,p_JCB
	INC  	p_JCB
	MOV  	R0,AR7
	MOV  	@R0,#02H
; 			break;
			; SOURCE LINE # 54
	SJMP 	?C0006
; 		}	
			; SOURCE LINE # 55
?C0008:
; 		++i;
			; SOURCE LINE # 56
	INC  	i
; 	}
			; SOURCE LINE # 57
	MOV  	A,#08H
	ADD  	A,p_JCB
	MOV  	p_JCB,A
	SJMP 	?C0005
?C0006:
; 	pTAK_RM_STK = C_TASKs_RAM_START + RN_TASK_IDX * C_TASKs_RAM_CAPACITY;//任务数据栈指针	
			; SOURCE LINE # 58
	MOV  	B,#020H
	MOV  	A,RN_TASK_IDX
	MUL  	AB
	MOV  	pTAK_RM_STK,B
	MOV  	pTAK_RM_STK+01H,A
; 	//恢复ACC	
; 	Cache_ACC = *(pTAK_RM_STK++);
			; SOURCE LINE # 60
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0036
	INC  	pTAK_RM_STK
?C0036:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	MOV  	Cache_ACC,A
; 	//恢复PSW
; 	*((uchar*)PSW) = *(pTAK_RM_STK++) & 0xE7;
			; SOURCE LINE # 62
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0037
	INC  	pTAK_RM_STK
?C0037:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	ANL  	A,#0E7H
	MOV  	R1,PSW
	MOV  	R2,#00H
	MOV  	R3,#00H
	LCALL	?C?CSTPTR
; 	//获取入口地址
; 	//先从任务RAM中获取		
; 	Cache_TaskEnter_L = *(pTAK_RM_STK++);
			; SOURCE LINE # 65
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0038
	INC  	pTAK_RM_STK
?C0038:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	MOV  	Cache_TaskEnter_L,A
; 	Cache_TaskEnter_H = *(pTAK_RM_STK++);
			; SOURCE LINE # 66
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0039
	INC  	pTAK_RM_STK
?C0039:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	MOV  	Cache_TaskEnter_H,A
; 	if(Cache_TaskEnter_L == 0x00 && Cache_TaskEnter_H == 0x00){
			; SOURCE LINE # 67
	MOV  	A,Cache_TaskEnter_L
	JNZ  	?C0009
	MOV  	A,Cache_TaskEnter_H
	JNZ  	?C0009
; 		//如果任务数据栈为空，则从JCB获取		
; 		Cache_TaskEnter_L = *(p_JCB++);
			; SOURCE LINE # 69
	MOV  	R7,p_JCB
	INC  	p_JCB
	MOV  	R0,AR7
	MOV  	A,@R0
	MOV  	Cache_TaskEnter_L,A
; 		Cache_TaskEnter_H = *(p_JCB++);		
			; SOURCE LINE # 70
	MOV  	R7,p_JCB
	INC  	p_JCB
	MOV  	R0,AR7
	MOV  	A,@R0
	MOV  	Cache_TaskEnter_H,A
; 	}	
			; SOURCE LINE # 71
?C0009:
; 	//切换任务栈的起始地址
; 	//先从任务数据栈中获取
; 	SP = *(pTAK_RM_STK++);
			; SOURCE LINE # 74
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0040
	INC  	pTAK_RM_STK
?C0040:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	MOV  	SP,A
; 	if(SP == 0){
			; SOURCE LINE # 75
	MOV  	A,SP
	JNZ  	?C0010
; 		//如果任务数据栈为空，则设置为初始任务栈地址
; 		SP = C_sgTASK_SP_SRART + RN_TASK_IDX * C_sgTASK_SP_CAPACITY;
			; SOURCE LINE # 77
	MOV  	A,RN_TASK_IDX
	SWAP 	A
	RLC  	A
	ANL  	A,#0E0H
	ADD  	A,#080H
	MOV  	SP,A
; 	}
			; SOURCE LINE # 78
?C0010:
; 	//恢复寄存器数据
; 	for(i=0x08;i<0x10;i++){			
			; SOURCE LINE # 80
	MOV  	i,#08H
?C0011:
; 		*((uchar data*)i) = *(pTAK_RM_STK++);
			; SOURCE LINE # 81
	INC  	pTAK_RM_STK+01H
	MOV  	A,pTAK_RM_STK+01H
	MOV  	R6,pTAK_RM_STK
	JNZ  	?C0041
	INC  	pTAK_RM_STK
?C0041:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R6
	MOVX 	A,@DPTR
	MOV  	R0,i
	MOV  	@R0,A
; 	}
			; SOURCE LINE # 82
	INC  	i
	MOV  	A,i
	CJNE 	A,#010H,?C0011
?C0012:
; 
; 	//跳转
; 	#pragma asm		
; 	MOV A,Cache_TaskEnter_L
	  MOV A,Cache_TaskEnter_L
; 	PUSH ACC
	  PUSH ACC
; 	MOV A,Cache_TaskEnter_H
	  MOV A,Cache_TaskEnter_H
; 	PUSH ACC
	  PUSH ACC
; 	MOV A,17H	
	  MOV A,17H	
; 	SETB RS0;切换寄存器组到第1区	
	  SETB RS0;切换寄存器组到第1区	
; 	RET
	  RET
?C0014:
; 	#pragma endasm	
; 	while(1);
			; SOURCE LINE # 94
	SJMP 	?C0014
; END OF OS_taskDispatch

; }
; 
; void OS_TaskRecover(){		

	RSEG  ?PR?OS_TaskRecover?OS
OS_TaskRecover:
	USING	0
			; SOURCE LINE # 97
; 	//设置JCB	
; 	p_JCB = C_JCB_START + RN_TASK_IDX * C_JCB_CAPACITY;//任务地址栈指针
			; SOURCE LINE # 99
	MOV  	A,RN_TASK_IDX
	MOV  	B,#08H
	MUL  	AB
	ADD  	A,#050H
	MOV  	p_JCB,A
; 	*p_JCB = JCB_DESTORY;	
			; SOURCE LINE # 100
	MOV  	R0,A
	CLR  	A
	MOV  	@R0,A
?C0017:
; 	while(1);
			; SOURCE LINE # 101
	SJMP 	?C0017
; END OF OS_TaskRecover

; }
; 
; void sleep(uchar ms)   

	RSEG  ?PR?_sleep?OS
_sleep:
	USING	0
			; SOURCE LINE # 104
;---- Variable 'ms?340' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 105
; 	unsigned char a,b,c;
;     for(c=ms;c>0;c--)
			; SOURCE LINE # 107
;---- Variable 'c?343' assigned to Register 'R7' ----
?C0020:
	MOV  	A,R7
	SETB 	C
	SUBB 	A,#00H
	JC   	?C0029
;       for(b=142;b>0;b--)
			; SOURCE LINE # 108
;---- Variable 'b?342' assigned to Register 'R6' ----
	MOV  	R6,#08EH
?C0023:
;         for(a=2;a>0;a--);
			; SOURCE LINE # 109
;---- Variable 'a?341' assigned to Register 'R5' ----
	MOV  	R5,#02H
?C0026:
	DJNZ 	R5,?C0026
?C0025:
	DJNZ 	R6,?C0023
?C0022:
	DEC  	R7
	SJMP 	?C0020
; }
			; SOURCE LINE # 110
?C0029:
	RET  	
; END OF _sleep

; 
; void addTask(uint task){		

	RSEG  ?PR?_addTask?OS
_addTask:
	USING	0
			; SOURCE LINE # 112
;---- Variable 'task?444' assigned to Register 'R6/R7' ----
; 	for(p_JCB = C_JCB_START; p_JCB < C_JCB_START + C_MAX_TASK_COUNT * C_JCB_CAPACITY; p_JCB += C_JCB_CAPACITY){
			; SOURCE LINE # 113
	MOV  	p_JCB,#050H
?C0030:
	MOV  	A,p_JCB
	CLR  	C
	SUBB 	A,#070H
	JNC  	?C0034
; 		if(*p_JCB == JCB_DESTORY){
			; SOURCE LINE # 114
	MOV  	R0,p_JCB
	MOV  	A,@R0
	JNZ  	?C0032
; 			*(p_JCB++) = JCB_BLOCK;
			; SOURCE LINE # 115
	MOV  	R5,p_JCB
	INC  	p_JCB
	MOV  	R0,AR5
	MOV  	@R0,#01H
; 			*(p_JCB++) = task;
			; SOURCE LINE # 116
	MOV  	R5,AR7
	MOV  	R4,p_JCB
	INC  	p_JCB
	MOV  	R0,AR4
	MOV  	@R0,AR5
; 			*(p_JCB++) = task >> 8;
			; SOURCE LINE # 117
	MOV  	R7,AR6
	MOV  	R6,p_JCB
	INC  	p_JCB
	MOV  	R0,AR6
	MOV  	@R0,AR7
; 			break;
			; SOURCE LINE # 118
	RET  	
; 		}
			; SOURCE LINE # 119
; 	}		
			; SOURCE LINE # 120
?C0032:
	MOV  	A,#08H
	ADD  	A,p_JCB
	MOV  	p_JCB,A
	SJMP 	?C0030
; }			; SOURCE LINE # 121
?C0034:
	RET  	
; END OF _addTask

	END
